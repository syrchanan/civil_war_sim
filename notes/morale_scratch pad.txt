# making morale a dynamic system ----

the fact that morale is scored 1-10 makes it difficult to control granularity (though I designed it this way to better let players understand the system). let's multiply the morale by 10 to initialize the value in the updater. We want to be able to dynamically track and update morale -- the more casualties sustained, the more morale falls; the more casualties inflicted, the more morale rises; the faster casualties are sustained, the more morale falls; the faster casualties are inflicted, the faster morale rises.

also, once the simulation ends, I want to round the remaining morale score to the nearest 10, so we can convert back to a 1-10 score.

how would you design this algorithm?

# results ----

You're looking to introduce a sophisticated dynamic morale system into your simulation, allowing it to react to the ebb and flow of battle and influence unit effectiveness. This is an excellent way to enhance the realism and strategic depth of your "Civil War Rules" game, as morale (or lack thereof) can lead to "mutiny or desertion".
Based on your request and drawing from the provided sources, here's a detailed algorithm for designing dynamic morale degradation and improvement, incorporating your specified requirements:
I. Core Design Principles & Initial Setup
1. Morale Scale Expansion:
    ◦ The "Civil War Rules" define morale on a 1-10 scale with descriptive tiers (e.g., "Desperate, plotting mutiny or desertion").
    ◦ As requested, to increase granularity, your internal simulation will track morale on a 10-100 scale.
    ◦ Initialization: When a unit (representing a side B or R in your markovchain_diffeq_sim) starts a simulation, its 1-10 morale score will be multiplied by 10 to get its initial granular morale (e.g., Morale 7 becomes 70).
2. Dynamic State Representation:
    ◦ The current markovchain_diffeq_sim function primarily tracks init (the number of units/soldiers for each side) and time. To track dynamic morale, the init vector (or an accompanying structure) within the markovchain_diffeq_sim loop must be augmented to hold each side's current granular morale score.
    ◦ For example, instead of just init = c("B" = 1000, "R" = 1200), the simulation's internal state (or variables accessible within the loop) would also need current_B_morale_granular and current_R_morale_granular.
    ◦ Crucial Additions: For the markovchain_diffeq_sim to dynamically update coefficients, it must also have access to the initial stat_xp and stat_weapon for each side, as these combine with morale to determine the final_combat_coefficient. These would need to be passed as new parameters to the simulation function.
II. Algorithm for Dynamic Morale Update (within )
The morale update logic needs to be integrated within the while (t < time) loop of your markovchain_diffeq_sim function, occurring after soldier counts (init) are updated from casualties.
For each simulation step (delta_t, which is min(clocks)):
1. Capture Pre-Step State:
    ◦ Before updating init (soldier counts), record the previous_B_soldiers and previous_R_soldiers.
2. Update Soldier Counts:
    ◦ init <- init + dir * tabulate(which.min(clocks), nbins = length(init)).
    ◦ Store the new soldier counts as current_B_soldiers and current_R_soldiers.
3. Calculate Casualties Taken/Inflicted:
    ◦ B_casualties_taken_this_step = previous_B_soldiers - current_B_soldiers
    ◦ R_casualties_taken_this_step = previous_R_soldiers - current_R_soldiers
    ◦ Conversely, B_casualties_inflicted_this_step = R_casualties_taken_this_step, and R_casualties_inflicted_this_step = B_casualties_taken_this_step.
    ◦ Store delta_t = min(clocks) for rate calculations.
4. Apply Morale Degradation/Improvement Rules:
    ◦ For each Side (e.g., Side B):
        ▪ Initialize morale_change_for_B = 0.
        ▪ Rule A: Casualties Sustained (Morale Falls):
            • Calculate loss_percentage = B_casualties_taken_this_step / previous_B_soldiers. (Handle division by zero if previous_B_soldiers is 0).
            • morale_change_for_B = morale_change_for_B - (loss_percentage * Morale_Loss_Constant_1)
            • (Rationale: A unit taking losses will experience a drop in morale. The previous_B_soldiers provides a stable baseline for this percentage calculation.)
        ▪ Rule B: Casualties Inflicted (Morale Rises):
            • Calculate infliction_percentage = R_casualties_taken_this_step / previous_R_soldiers. (Handle division by zero if previous_R_soldiers is 0).
            • morale_change_for_B = morale_change_for_B + (infliction_percentage * Morale_Gain_Constant_1)
            • (Rationale: Successfully inflicting casualties boosts morale, reflecting "High-spirited, eager" or "Patriotic exuberance!".)
        ▪ Rule C: Faster Casualties Sustained (More Morale Falls):
            • Calculate casualties_per_unit_time_taken = B_casualties_taken_this_step / delta_t. (Handle delta_t being zero or extremely small to avoid Inf or NaN; you might cap this value or add a small epsilon to delta_t).
            • morale_change_for_B = morale_change_for_B - (casualties_per_unit_time_taken * Morale_Loss_Constant_2)
            • (Rationale: Rapid, heavy losses are more demoralizing than slow attrition, even for the same total casualty count. This reflects the "shaken, shell-shocked" state.)
        ▪ Rule D: Faster Casualties Inflicted (Faster Morale Rises):
            • Calculate casualties_per_unit_time_inflicted = R_casualties_taken_this_step / delta_t. (Handle delta_t being zero or extremely small).
            • morale_change_for_B = morale_change_for_B + (casualties_per_unit_time_inflicted * Morale_Gain_Constant_2)
            • (Rationale: A rapid, successful advance or defense significantly boosts a unit's spirit.)
        ▪ Update B's Morale:
            • current_B_morale_granular = current_B_morale_granular + morale_change_for_B
            • Clamp Morale: current_B_morale_granular = max(10, min(100, current_B_morale_granular)). This ensures morale stays within the 10-100 granular range, corresponding to the original 1-10 "Desperate" to "Patriotic exuberance" scale.
    ◦ Repeat the same logic for Side R's morale.
5. Dynamically Update Combat Coefficients (coef) and rate_func:
    ◦ This is a critical step because unit effectiveness depends on morale. Since morale has changed, the rate_func (which uses coef) must reflect this.
    ◦ Convert granular morale back to 1-10 for calculation:
        ▪ B_morale_1_10 = round(current_B_morale_granular / 10)
        ▪ R_morale_1_10 = round(current_R_morale_granular / 10)
    ◦ Recalculate final_combat_coefficient for each side:
        ▪ To do this, you would need to either:
            • Call a function that mimics the relevant parts of get_coef_lookup_table (specifically, applying morale_boost_per_level based on the new B_morale_1_10 or R_morale_1_10, and combining it with the fixed stat_xp, stat_weapon, and stat_melee for that side).
            • Or, if get_coef_lookup_table generates a true lookup table, you would query it using the updated morale value (after rounding back to 1-10), along with the side's fixed XP, Weapon, and Melee status.
        ▪ Let these new coefficients be new_coef_B and new_coef_R.
    ◦ Re-generate rate_func: You would then need to re-call (or adapt the logic from) build_lanchester_diffeq with these new_coef_B and new_coef_R to generate updated rate_func closures for the next iteration of the while loop. This might involve changing build_lanchester_diffeq to accept mutable coefficients, or rebuilding the entire rate_func structure on each morale update.
6. Record State:
    ◦ After updating soldiers and morale, record the current state (time, current_B_soldiers, current_R_soldiers, current_B_morale_granular, current_R_morale_granular) to your output data frame.
7. Early Stopping Condition:
    ◦ Immediately after updating current_B_morale_granular and current_R_morale_granular:
        ▪ Add a new if condition: if (current_B_morale_granular < 10 || current_R_morale_granular < 10) break.
        ▪ (Rationale: A granular morale of 10 corresponds to a 1-2 morale score, which is "Desperate, plotting mutiny or desertion". This is the logical point for a unit to break and cease fighting, triggering early termination of the simulation for that side or the entire engagement.)
        ▪ The existing if (any(init == 0)) break for zero soldiers remains valid.
III. Post-Simulation Processing
• Final Morale Rounding: Once the simulation loop concludes (either by reaching time, a side losing all soldiers, or a side's morale breaking), take the final current_B_morale_granular and current_R_morale_granular values.
• Convert back to 1-10 scale: For reporting to players and for consistency with the "Civil War Rules," round the granular score to the nearest 10, then divide by 10.
    ◦ final_B_morale_1_10 = round(current_B_morale_granular / 10)
    ◦ final_R_morale_1_10 = round(current_R_morale_granular / 10)
IV. Tuning and Implementation Considerations
• Morale Constants (Morale_Loss_Constant_1, Morale_Gain_Constant_1, Morale_Loss_Constant_2, Morale_Gain_Constant_2): These constants are crucial for balancing. They will require careful experimentation and tuning to ensure that morale changes are significant enough to matter but not so volatile that battles are over too quickly or never end.
• Performance Impact: Dynamically recalculating combat coefficients and rate_func within every small delta_t step of the markovchain_diffeq_sim could be computationally intensive. If performance becomes an issue, consider updating morale and coefficients less frequently (e.g., only after a fixed interval of time has passed, or after a certain cumulative percentage of casualties).
• Aggregated Unit Stats: The current markovchain_diffeq_sim and build_lanchester_diffeq work with aggregate 'sides' (B and R). To calculate final_combat_coefficient using stat_xp, stat_weapon, and stat_melee, you'd need to define what these mean for an entire side. This could be an average of all regiments on that side, or it could be a simplifying assumption that these stats are representative and fixed for the entire side for the duration of the engagement, with only morale being dynamic. The get_coef_lookup_table clearly outlines how these elements contribute to the final_combat_coefficient.
By implementing these steps, you will transform your static combat simulations into a dynamic system where unit spirit genuinely influences the outcome, adding a layer of depth that aligns with the strategic emphasis of the "Civil War Rules".